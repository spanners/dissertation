<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Simon Buist" />
  <title>The potential of declarative programming languages to support user interface programming: the case of ELM</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">The potential of declarative programming languages to support user interface programming: the case of ELM</h1>
<h2 class="author">Simon Buist</h2>
<h3 class="date">March 2014</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#copyright">COPYRIGHT</a></li>
<li><a href="#declaration">Declaration</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="#example-section"><span class="toc-section-number">1.1</span> Example Section</a><ul>
<li><a href="#example-subsection"><span class="toc-section-number">1.1.1</span> Example Subsection</a></li>
</ul></li>
<li><a href="#another-section"><span class="toc-section-number">1.2</span> Another section</a></li>
</ul></li>
<li><a href="#literature-survey"><span class="toc-section-number">2</span> Literature Survey</a><ul>
<li><a href="#introduction-to-the-problem-area"><span class="toc-section-number">2.1</span> Introduction to the problem area</a></li>
<li><a href="#what-does-it-mean-to-be-easy-to-use"><span class="toc-section-number">2.2</span> What does it mean to be ‘easy to use?’</a></li>
<li><a href="#running-user-studies"><span class="toc-section-number">2.3</span> Running User Studies</a></li>
</ul></li>
<li><a href="#requirements"><span class="toc-section-number">3</span> Requirements</a></li>
<li><a href="#design"><span class="toc-section-number">4</span> Design</a><ul>
<li><a href="#pilot-study"><span class="toc-section-number">4.1</span> Pilot study</a></li>
<li><a href="#experimental-design"><span class="toc-section-number">4.2</span> Experimental design</a></li>
</ul></li>
<li><a href="#implementation-and-testing"><span class="toc-section-number">5</span> Implementation and Testing</a></li>
<li><a href="#results"><span class="toc-section-number">6</span> Results</a></li>
<li><a href="#conclusions"><span class="toc-section-number">7</span> Conclusions</a></li>
</ul>
</div>
<p>This dissertation may be made available for consultation within the University Library and may be photocopied or lent to other libraries for the purposes of consultation.</p>
<p>Signed: </p>
<p><strong>The potential of declarative programming languages to support user interface programming: the case of ELM</strong></p>
<p>Submitted by: Simon Buist</p>
<h1 id="copyright" class="unnumbered">COPYRIGHT</h1>
<p>Attention is drawn to the fact that copyright of this dissertation rests with its author. The Intellectual Property Rights of the products produced as part of the project belong to the author unless otherwise specified below, in accordance with the University of Bath’s policy on intellectual property (see http://www.bath.ac.uk/ordinances/22.pdf). This copy of the dissertation has been supplied on condition that anyone who consults it is understood to recognise that its copyright rests with its author and that no quotation from the dissertation and no information derived from it may be published without the prior written consent of the author.</p>
<h1 id="declaration" class="unnumbered">Declaration</h1>
<p>This dissertation is submitted to the University of Bath in accordance with the requirements of the degree of Bachelor of Science in the Department of Computer Science. No portion of the work in this dissertation has been submitted in support of an application for any other degree or qualification of this or any other university or institution of learning. Except where specifically acknowledged, it is the work of the author.</p>
<p>Signed: </p>
<h1 id="acknowledgements" class="unnumbered">Acknowledgements</h1>
<p>Add any acknowledgements here. </p>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>This is the introductory chapter.</p>
<h2 id="example-section"><span class="header-section-number">1.1</span> Example Section</h2>
<p>Like all chapters, it will have a number of sections</p>
<h3 id="example-subsection"><span class="header-section-number">1.1.1</span> Example Subsection</h3>
<p>…and sub-sections</p>
<h4 id="example-sub-subsection"><span class="header-section-number">1.1.1.1</span> Example sub-subsection</h4>
<p>…and sub-subsections.</p>
<h4 id="table"><span class="header-section-number">1.1.1.2</span> Table</h4>
<table>
<caption>An example table</caption>
<col width="12%" />
<col width="12%" />
<thead>
<tr class="header">
<th align="left">Items</th>
<th align="left">Values</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Item 1</td>
<td align="left">Value 1</td>
</tr>
<tr class="even">
<td align="left">Item 2</td>
<td align="left">Value 2</td>
</tr>
</tbody>
</table>
<h2 id="another-section"><span class="header-section-number">1.2</span> Another section</h2>
<p>Another section, just for good measure. You can reference a table, figure or equation using <a href="#table">table</a></p>
<h1 id="literature-survey"><span class="header-section-number">2</span> Literature Survey</h1>
<h2 id="introduction-to-the-problem-area"><span class="header-section-number">2.1</span> Introduction to the problem area</h2>
<p>Spending half an hour making a mind-map, starting with the word “Elm”, I get the following terms:</p>
<ul>
<li><p>Signals</p>
<ul>
<li><p>Impure</p></li>
<li><p>Time</p></li>
<li><p>Input/Output</p></li>
<li><p>History – Past &amp; Future</p></li>
<li><p>Data model</p></li>
</ul></li>
<li><p>“Natural” Separation of Data model/Logic/Layout</p></li>
<li><p>Less cognitive load?</p></li>
<li><p>“Easy”</p>
<ul>
<li><p>Professed to be “easy” by the creator!</p></li>
<li><p>What does it mean to be “easy”?</p></li>
<li><p>Operationalisation</p></li>
<li><p>Self-reporting</p></li>
</ul></li>
<li><p>Programming Language</p>
<ul>
<li><p>Reactive</p>
<ul>
<li><p>“Instant feedback”</p></li>
<li><p>“I/O-sensitive”</p></li>
<li><p>Thrashing?</p></li>
</ul></li>
<li><p>Functional</p>
<ul>
<li><p>Pure</p></li>
<li><p>Testing</p>
<ul>
<li><p>properties</p></li>
<li><p>QuickCheck</p></li>
<li><p>Delta Debugging</p></li>
</ul></li>
</ul></li>
<li><p>Haskell derivative</p>
<ul>
<li><p>Embedded Domain-specific Language</p></li>
<li><p>See also: Idris</p></li>
</ul></li>
<li><p>Multiple back-ends</p>
<ul>
<li><p>Javascript</p></li>
<li><p>Java</p></li>
<li><p>C</p></li>
</ul></li>
</ul></li>
<li><p>Programming</p>
<ul>
<li><p>code-compile-run loop</p>
<ul>
<li><p>“Programming blind”</p></li>
<li><p>“Slow feedback”</p></li>
</ul></li>
<li><p>Text editor</p></li>
<li><p>IDE</p></li>
<li><p>Paradigms</p>
<ul>
<li><p>Declarative</p></li>
<li><p>I’ll tell you WHAT I want you to do, you figure out HOW to do it</p></li>
</ul></li>
<li><p>Encoding ideas</p>
<ul>
<li><p>Mapping of natural language concepts into formal language</p></li>
<li><p>Loss of information?</p></li>
<li><p>Augmented reality?</p></li>
</ul></li>
<li><p>Abstraction</p>
<ul>
<li><p>What level?</p></li>
<li><p>What generation? 3GL? 4GL?</p></li>
<li><p>Metaprogramming e.g. AspectJ</p></li>
<li><p>Black/White box</p></li>
</ul></li>
<li><p>Cognitive offloading</p></li>
<li><p>What is it?</p>
<ul>
<li><p>Art?</p></li>
<li><p>Engineering?</p></li>
<li><p>Science?</p></li>
<li><p>Language?</p></li>
<li><p>Mathematics?</p></li>
<li><p>Ephemeral</p></li>
<li><p>Intangible</p></li>
<li><p>Limitless</p></li>
<li><p>Limited</p></li>
</ul></li>
</ul></li>
<li><p>IDE</p>
<ul>
<li>Split View: Code | Runtime</li>
</ul></li>
<li><p>Feedback</p>
<ul>
<li><p>“Instant-update”</p></li>
<li><p>On-the-fly</p></li>
</ul></li>
</ul>
<p>The problem area of user-interface programming, and more generally, the activity of programming in a context such as a software engineering environment, encompasses certain realms of interest. Through my survey of literature, my research has touched upon the above-mentioned terms, and I have discovered some thought-provoking problems that exist in the field of programming. The concept of ‘Programming’ embodies other concepts – art-forms, engineering processes, science, language, and mathematics, among others. To me, programming is a creative endeavour unlike any other – in which the programmer weilds materials of no substance – the code – by manipulating symbols on a screen, which represent states in the machine being used. There are so many programming languages, and all languages (all that are Turing-complete) reduce to the same language – that of a Turing Machine. So, <em>why do we have so many programming languages?</em>.</p>
<p><em>Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.</em> <span class="citation">(Perlis, 1982)</span></p>
<p>Different languages lend themselves to different ways of thinking about problems. They may place emphasis on one feature, for example list manipulation and hide others such as types. The language or programming environment may make explicit the effect of changes as they are encoded, as opposed to queuing up a block of changes and the programmer having to initiate an update manually.</p>
<p>I would like to draw your attention in particular to the terms <strong>Abstraction</strong>, <strong>Cognitive offloading</strong>, <strong>Feedback</strong>, <strong>Loss of information?</strong>/<strong>Augmented reality?</strong>, <strong>Thrashing</strong>, and <strong>“Programming blind”</strong>. These, at current, are my topics of interest, and my literature review has up to this point been inextricably and heavily influenced by this.</p>
<h2 id="what-does-it-mean-to-be-easy-to-use"><span class="header-section-number">2.2</span> What does it mean to be ‘easy to use?’</h2>
<p>In the process of surveying relevant (and sometimes irrelevant) literature to this dissertation, recurring conceptual patterns were observed – one particular instance of this is that several authors seem to lay victim to the trap of claiming their creation is “easy to use”, “better”, “simpler than <span class="math"><em>x</em></span>” without providing any supportive evidence of this.</p>
<p>Perhaps these are incidents of ‘experimenter bias’ – where the evaluator is naturally predisposed to a positive appraisal of their own findings. One way to avoid this is to have one set of people perform the data capture and another set perform the data analysis. Nevertheless, these patterns emerge, and present numerous opportunities for experimentation and subsequent evidence supporting or contradicting these claims. Experiments may see if the same conclusions are reached as the above-mentioned authors, accounting for the ‘evaluator effect’ <span class="citation">(Hertzum &amp; Jacobsen, 2001)</span>.</p>
<p>Whether this particular route is taken for experimentation hinges on pilot studies that will be conducted concurrently to the Literature Survey, each inextricably shaping the other’s direction of investigation and inquiry.</p>
<p>The catalyst to this whole dissertation was a talk about the concept of a highly reactive development environment – where changes in the code result in instantaneous updates to the runtime, ‘on-the-fly’. This was presented in Bret Victor’s “Inventing on Principle” <span class="citation">(Victor, 2012)</span>. In his presentation Bret makes several assertions about the ‘traditional’ style of coding, one statement of which is that “most of the developer’s time is spent looking at the code, blindly without an immediate connection to the thing they’re making”. He argues that “so much of creation is discovery, and you can’t discover anything if you can’t see what you’re doing” – alluding to his earlier statement that the compile-run-debug cycle is much like this.</p>
<p>Evan Czaplicki, in his thesis of which Elm is the product <span class="citation">(Czaplicki, 2012)</span>, makes similar claims – “[Elm] makes it <em>quick and easy</em> to create and combine text, images, and video into rich multimedia displays.” While the evaluation of Elm’s usability is not the focus of the thesis, rather, it is to establish a context for Functional Reactive Programming and describe the implementation details, he makes other usability claims without evidence – “[non-declarative frameworks for graphical user interfaces] mire programmers in the many small, nonessential details of handling user input and modifying the display.”, “FRP makes GUI programming much more manageable”, and in a section entitled <em>The Benefits of Functional GUIs</em>, “In Elm, divisions between data code, display code, and user interaction code arise fairly naturally, helping programmers write robust GUI code”. If these claims are true, there is all the more evidence that Elm should be a language of choice for GUI programmers, but experiments must be done to determine this.</p>
<p>And perhaps this rapid development cycle is not always suitable – in their 2012 paper, Lopez et al. show that novices tend to “thrash” about, trying out many ideas that may or may not be a solution, and executing “poorly directed, ineffective problem solving …failing to realise they are doing it in good time, and fail to break out of it”, whereas experts think much more about the problem at hand before proceeding with a solution <span class="citation">(Lopez et al., 2012)</span>.</p>
<h2 id="running-user-studies"><span class="header-section-number">2.3</span> Running User Studies</h2>
<p>Perhaps a further direction of investigation may be running an experiment to spot whether or not Elm’s auto-updating IDE lends to a lack of critical thinking – some operationalization may be <em>pauses reported as ‘thinking’ made during development</em> – where a pause is disambiguated as ‘thinking’ by the experimenter asking the participant why they did not perform any interaction with the computer for more than 10 seconds, and the participant reports that they were planning/designing/other similar activity. Along this line of thinking, a paper studying the relationship between speech pauses and cognitive load <span class="citation">(Khawaja et al., 2008)</span> found through studying 48 mixed gender participants that there is statistically significant indicators of cognitive load through analysing pauses in speech. Perhaps this concept of pauses can be applied to the activity of programming. However, the planned method of disambiguating pauses via self-reporting (previously mentioned) would not be suitable according to these authors – “such measures can be either physically or psychologically intrusive and disrupt the normal flow of the interaction”, although a paper cited by <span class="citation">(Khawaja et al., 2008)</span> itself claims that “although self-ratings may appear questionable, it has been demonstrated that people are quite capable of giving a numerical indication of their perceived mental burden <span class="citation">(Gopher &amp; Braune, 1984)</span>”. Indeed a pilot study by Fraser and Kölling <span class="citation">(McKay &amp; K<span>ö</span>lling, 2012)</span> structures the self-reporting by getting the users to evaluate an IDE as they use it using a set of subject-specific heuristics that they have designed. They showed that this customised set of heuristics helped guide the user more effectively than Nielsen’s heuristics in evaluating usability, so one could develop a custom set of heuristics for evaluating the usability of Elm.</p>
<p>From the Elm thesis <span class="citation">(Czaplicki, 2012)</span>, the language syntax and rapid feedback seem simple enough that it is conceivable (or at the very least, possible and of experimental interest) to allow the user to customise the UI layout to their liking. Letting the user shape the UI in concert with a UI programmer is covered the study of the interface development environment “Mobi-D” in millitary and medical applications <span class="citation">(Puerta, 1997)</span>, with success in those fields. It may be worth speculating how Elm would fit into the development cycle that Puerta’s paper outlines, as this may lend inspiration to potential user interface enhancements to the Elm IDE for A/B testing. It must be noted that there does not seem to be a re-emergence of Mobi-D since the paper was written, however.</p>
<p>My goal is to answer these questions. By way of conducting user studies, leveraging Elm with extensions to do A/B testing to illustrate it’s effectiveness (or ineffectiveness) at enhancing User Interface Design.</p>
<p>Central to this idea of iteration is my desired method of performing user studies: I will first do what I have called a “Pilot” – a short and shallow trial User Study that focuses not on the research I’m concerned with, but instead the particular experimental design I would like to use in my actual User Study. By employing a Pilot I can hopefully get an idea of the nature of the experimental design – perhaps discovering any variables I had not previously considered that will require me to increase my sample size or simplify the experiment in order to mitigate their effect on the dependent variable I wish to test for. These are all problems discovered in <span class="citation">(Yates, 2012)</span> – including basic teething problems in getting the experiment to flow smoothly. In an even less detailed aspect, the pilot may allow me to look at what is out there. It may help to not look for anything in particular initially, and see what happens.</p>
<p>At this stage, with the help of discussion with my Project Supervisor, I have some ideas about how to gather data in User Studies and these pilots could prove to be a useful testbed for such tools. I have a hypothesis that the novice developer “thrashing” <span class="citation">(Lopez et al., 2012)</span> can be observed by shorter pauses between editing and experimentation, and I could measure this by way of measuring the mouse position relative to the IDE, clicks, and key-presses, using tools built-in to Elm and a bit of extension to stream this over the Internet to my storage facilities <span class="citation">(Czaplicki, 2013)</span>.</p>
<h1 id="requirements"><span class="header-section-number">3</span> Requirements</h1>
<p>If you are doing a primarily software development project, this is the chapter in which you review the requirements decisions and critique the requirements process.</p>
<h1 id="design"><span class="header-section-number">4</span> Design</h1>
<p>This is the chapter in which you review your design decisions at various levels and critique the design process.</p>
<h2 id="pilot-study"><span class="header-section-number">4.1</span> Pilot study</h2>
<p>In reflection, the task I chose was too difficult to capture the cognitive load incurred by the language itself for a given task, due to the difficulty of the task itself creating noise. I could improve this by simplifying the task, in a way that is ‘language agnostic’, i.e. that is not idiomatic of Elm or JavaScript (the two languages that I am comparing). Something like the following will never be that easy in JavaScript:</p>
<table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="co">-- | Inefficient quicksort in haskell.</span>
<span class="ot">qsort ::</span> (<span class="dt">Enum</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
qsort []     <span class="fu">=</span> []
qsort (x<span class="fu">:</span>xs) <span class="fu">=</span> qsort (filter (<span class="fu">&lt;</span> x) xs) <span class="fu">++</span> [x] <span class="fu">++</span>
               qsort (filter (<span class="fu">&gt;=</span> x) xs) </code></pre></td></tr></table>
<table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell">main <span class="fu">=</span> lift asText Mouse.position</code></pre></td></tr></table>
<h2 id="experimental-design"><span class="header-section-number">4.2</span> Experimental design</h2>
<p>Foo</p>
<h1 id="implementation-and-testing"><span class="header-section-number">5</span> Implementation and Testing</h1>
<p>This is the chapter in which you review the implementation and testing decisions and issues, and critique these processes. Code can be output inline using <code>some code</code>. For example, this code is inline: <code>public static int example = 0;</code> (I have used the character | as a delimiter, but any non-reserved character not in the code text can be used.) Code snippets can be output using the environment with the code given in the environment. For example, consider listing 5.1, below. Listing 5.1: Example code</p>
<p>Code listings are produced using the package “Listings”. This has many useful options, so have a look at the package documentation for further ideas.</p>
<h1 id="results"><span class="header-section-number">6</span> Results</h1>
<p>This is the chapter in which you review the outcomes, and critique the outcomes process. You may include user evaluation here too.</p>
<h1 id="conclusions"><span class="header-section-number">7</span> Conclusions</h1>
<p>This is the chapter in which you review the major achievements in the light of your original objectives, critique the process, critique your own learning and identify possible future work.</p>
<div class="references">
<h1><span class="header-section-number">7</span> Bibliography</h1>
<p>Czaplicki, E. (2012) ‘Elm: Concurrent FRP for Functional GUIs’,</p>
<p>Czaplicki, E. (2013) ‘What is functional reactive programming?’, [online] Available from: <a href="http://elm-lang.org/learn/What-is-FRP.elm">http://elm-lang.org/learn/What-is-FRP.elm</a> (Accessed 1 October 2013).</p>
<p>Gopher, D. and Braune, R. (1984) ‘On the psychophysics of workload: Why bother with subjective measures?’, <em>Human Factors: The Journal of the Human Factors and Ergonomics Society</em>, SAGE Publications, 26(5), pp. 519–532.</p>
<p>Hertzum, M. and Jacobsen, N. E. (2001) ‘The evaluator effect: A chilling fact about usability evaluation methods’, <em>International Journal of Human-Computer Interaction</em>, Taylor &amp; Francis, 13(4), pp. 421–443.</p>
<p>Khawaja, M. A., Ruiz, N. and Chen, F. (2008) ‘Think before you talk: An empirical study of relationship between speech pauses and cognitive load’, In <em>Proceedings of the 20th australasian conference on computer-human interaction: Designing for habitus and habitat</em>, OZCHI ’08, New York, NY, USA, ACM, pp. 335–338, [online] Available from: <a href="http://doi.acm.org/10.1145/1517744.1517814">http://doi.acm.org/10.1145/1517744.1517814</a>.</p>
<p>Lopez, T., Petre, M. and Nuseibeh, B. (2012) ‘Thrashing, tolerating and compromising in software development’, In Jing, Y. (ed.), <em>Psychology of Programming Interest Group Annual Conference (PPIG-2012)</em>, London Metropolitan University, UK, London Metropolitan University, pp. 70–81.</p>
<p>McKay, F. and K<span>ö</span>lling, M. (2012) ‘Evaluation of subject-specific heuristics for initial learning environments: A pilot study’, In <em>Proceedings of the 24th Psychology of Programming Interest Group Annual Conference 2012</em>, London Metropolitan University, pp. 128–138.</p>
<p>Perlis, A. J. (1982) ‘Epigrams on programming’, <em>SIGPLAN Notices</em>, 17(9), pp. 7–13.</p>
<p>Puerta, A. R. (1997) ‘A Model-Based Interface Development Environment’, <em>IEEE Softw.</em>, Los Alamitos, CA, USA, IEEE Computer Society Press, 14(4), pp. 40–47, [online] Available from: <a href="http://dx.doi.org/10.1109/52.595902">http://dx.doi.org/10.1109/52.595902</a>.</p>
<p>Victor, B. (2012) ‘Inventing on principle’, In <em>Proceedings of the canadian university software engineering conference (CUSEC)</em>, [online] Available from: <a href="http://vimeo.com/36579366">http://vimeo.com/36579366</a> (Accessed 15 March 2014).</p>
<p>Yates, R. (2012) ‘Conducting field studies in software engineering: An experience report’, In Jing, Y. (ed.), <em>Psychology of Programming Interest Group Annual Conference (PPIG-2012)</em>, London Metropolitan University, UK, London Metropolitan University, pp. 82–85.</p>
</div>
<h1 id="appendix-a">Appendix A</h1>
<h2 id="design-diagrams">Design Diagrams</h2>
<h1 id="appendix-b">Appendix B</h1>
<h2 id="user-documentation">User Documentation</h2>
<h1 id="appendix-c">Appendix C</h1>
<h2 id="raw-results-output">Raw results output</h2>
<h1 id="appendix-d">Appendix D</h1>
<h2 id="code">Code</h2>
<h1 id="appendix-e">Appendix E</h1>
<h2 id="meeting-minutes-sample">Meeting minutes (sample)</h2>
<p>Group meeting with Leon at East Building, 11:15 Friday 4th October 2013</p>
<h1 id="n.b.-read-up-on-and-remind-yourself-of-hci-stuff-year-2-and-software">N.B. READ UP ON AND REMIND YOURSELF OF HCI STUFF (Year 2) AND SOFTWARE</h1>
<p>ENGINEERING STUFF (Year 1)</p>
<h2 id="reading-material">Reading material</h2>
<p>In email repsonse to request for FYP meeting, <strong>Leon writes:</strong></p>
<pre><code>Please do a bit of reading around beforehand. Go to the ACM Digital Library
and search on &#39;user interface programming&#39;.</code></pre>
<ol style="list-style-type: decimal">
<li><a href="http://libproxy.bath.ac.uk/login?qurl=http%3A%2F%2Fdl.acm.org%2Fevent.cfm%3Fid%3DRE151">ACM Conference on Human Factors in Computing Systems</a></li>
<li><a href="http://libproxy.bath.ac.uk/login?qurl=http%3A%2F%2Fdl.acm.org%2Fevent.cfm%3Fid%3DRE169">ACM CSCW: Conference on Computer Supported Cooperative Work</a></li>
<li><a href="http://libproxy.bath.ac.uk/login?qurl=http%3A%2F%2Fdl.acm.org%2Fevent.cfm%3Fid%3DRE172">ACM UIST: Symposium on User Interface Software and Technology</a></li>
</ol>
<p>In moodle project page, <strong>Leon writes:</strong></p>
<pre><code>Your project must be related to contemporary developments in Human-Computer
Interaction, and preferably to the part of the HCI world that focuses on
interactive systems for collaboration.</code></pre>
<ol style="list-style-type: decimal">
<li>???</li>
<li>???</li>
</ol>
<p>Also In moodle project page, <strong>Leon also writes:</strong></p>
<pre><code>It normally starts with some user-centred research (observations,
interviews, pilot experiment) to ground the problem, carried out
concurrently with literature research.  The research problem is normally
boiled down to something that can be addressed through the production of
alternative versions of an interactive system. 

This is closely followed by initial design work and the production of a
rough but working prototype leading up to Christmas. 

After the January exams, my students typically re-scope their research
problem, based in the outcome of their initial work, and solidify their
implementation ready for a full evaluation in March and April.</code></pre>
<p>Thus, my answers to the questions Leon posed should follow this structure in terms of what I want to get out of it. I can use the above structure to identify <strong>concerns</strong> of potential challenges in each step/combination of steps/step-transitions (e.g. step dependencies, resource procurement)</p>
<p>Also in moodle product page, <strong>Leon also writes:</strong></p>
<pre><code>Students should prepare for their projects by refreshing their memories
about Interaction from CM20216 activities. You should read about HCI in
general, and support for collaboration in particular. Look at any or all of
the following book chapters:</code></pre>
<ul>
<li>Sharp, Rogers and Preece (2007) Interaction Design. hapter 4: Designing to Support Communication and Collaboration.</li>
<li>Dix, Finlay, Abowd and Beale (2004) Human-Computer Interaction. hapter 14: Communication and Collaboration Models.</li>
<li>Shneiderman and Plaisant (2005) Designing the User Interface. hapter 10: Collaboration.</li>
</ul>
<h1 id="leon-asked-us-to-answer-these-questions-and-bring-a-notebook">Leon asked us to answer these questions and bring a notebook:</h1>
<h2 id="q1.-what-i-hope-to-get-out-of-my-fyp-as-an-experience">Q1. What I hope to get out of my FYP as an experience?</h2>
<p>I hope to gain a deep and meaningful understanding of the programmer as a user, as an individual and the context of that individual -- e.g. in a software team inside a department, inside a management structure... inside a company.</p>
<p>I hope to use this understanding to determine processes/work-flows that programmers experience in the endeavour of User Interface Design, both from the individual perspective and as a team.</p>
<p>Within these work flows, I wish to identify, in detail, metrics to gauge productivity, in order to measure this in experiments, perhaps doing A/B testing with Elm and some other, perhaps procedural language. This is an example of an objective measure.</p>
<p>I would also like to gather self-reported, more &quot;fuzzy&quot; feedback on user's perception of their productivity -- pain points, advantages, etc. they experience in using Language X to product a UI compared to Language Y (Declarative languages like Elm, etc)</p>
<p>I wish to verify, empirically, the comparisons and claims made on the <a href="http://elm-lang.org/learn/What-is-FRP.elm">What is FRP?</a> page of the elm-lang.org website, and those claimed it's research paper (detailing the implementation of Elm, <strong>benefits</strong>, etc.)</p>
<p>In email again, <strong>Leon writes:</strong></p>
<pre><code>The Elm site makes **comparative statements.** That is encouraging because
it sets up opportunities for you to test some of the claims they make, and
to ask new questions about Elm that its proponents may not have considered.</code></pre>
<p>These are:</p>
<ol style="list-style-type: decimal">
<li>&quot;most current frameworks for graphical user interfaces are not declarative. They mire programmers in the many small, nonessential details of handling user input and manually modifying the display.&quot;</li>
<li>&quot;with FRP, many of the irrelevant details are left to the compiler, freeing the programmer to think about things that matter.&quot;</li>
<li>&quot;Coding <a href="http://elm-lang.org/Examples.elm">these examples</a> in a traditional GUI framework such as HTML/CSS/JavaScript . would require significantly more work and headache.&quot;</li>
<li>&quot;Not only is that painful to code, but it also requires broad and deep knowledge of inconsequential things.&quot;</li>
<li>&quot;FRP makes tasks considerably easier by taking care of the messy .how. of events, display, and updates.&quot;</li>
</ol>
<h2 id="q2.-where-my-project-idea-came-from-what-inspired-me">Q2. Where my Project Idea came from (what inspired me)?</h2>
<ul>
<li>The pain of coding and writing GUIs in PyQt4 while at my last job at Altran</li>
<li>The joys of coding in Haskell</li>
<li>The pain of writing GUIs in Haskell</li>
<li>The joys of coding and writing GUIs in Elm!</li>
</ul>
<h2 id="q3.-what-are-my-concerns">Q3. What are my concerns?</h2>
<ol style="list-style-type: decimal">
<li>Difficulty procuring programmers (users) -- specifically those that meet my criteria of not having used a declarative programming language.</li>
<li>Difficulty procuring programmers working in a team</li>
<li>The complexity/scope of the project -- is it enough for a FYP; is it too much?</li>
<li>Looking at the production of User Interfaces using a programming language, there are many variables -- how will I devise an experiment to minimise this and isolate a variable so that I can make some causal/correlational conclusions?</li>
<li>Concern regarding the dependency of a subsequent part of the project on a previous step -- this is inherent of all projects, though.</li>
</ol>
<hr />
<h1 id="am-in-stv-individual-meeting-after-proposal-hand-in">30/10/2013 @ 9:15 am in STV ## Individual Meeting after Proposal hand-in</h1>
<p>Our discussion centered around the direction I wish to take following my Project Proposal.</p>
<h3 id="ab-testing-of-the-language-with-the-same-ide">AB Testing of the language with the same IDE</h3>
<p>The primary direction I mentioned (as echoed in my Proposal) was doing AB testing of Elm vs. another language (e.g. JavaScript) (i.e. the language is the dependent variable) using the same Concurrent FRP IDE (the independent variable).</p>
<h3 id="test-just-the-paradigm">Test just the paradigm</h3>
<p>He also suggested a potential experiment to test just the paradigm, eliminating the IDE from the experiment above. Perhaps for a Pilot study.</p>
<h3 id="experiment-process">Experiment process</h3>
<ol style="list-style-type: decimal">
<li>Study question (e.g. Is it easy?)</li>
<li>Measurement concept (e.g. &quot;Easy&quot;)</li>
<li>Operationalisation -- taking a measurement concept and mapping it to something concrete (e.g. if completing a pre-defined task the user must complete takes &lt; 5 steps, it is 'easy' -- we can then compare instances of these studies given our definition of easy). This is much like mapping a design to an implementation, and there is a risk of losing information, or ending up with a mismatched concrete instance that does not represent the concept we wish to convey.</li>
<li>Do another operationalisation of our measurement concept -- this allows us to get a different perspective of the same concept. (e.g. if total length of pauses during a 1 hour experiment is &lt; 10 minutes, it is 'easy'). We do this to get 'coverage' of the measurement concept. It is a form of cross validation. If we see an overlap in the correlational results after analysis, we can make a stronger assertion that e.g. &quot;language A is easier than language B.&quot;. The idea I am describing here is methodological decision-making.</li>
<li>Predict what will be the likely results of our experiments on the operationalised measurements. This is &quot;feed forward validation&quot;.</li>
<li>Do the experiement.</li>
<li>Analyse the data. See if the data has patterns that correlate with the assertion I wish to make. I will be representing the raw data in some outcome measure -- that is turning the raw data into a set of (or a single) value for comparison.</li>
<li>Does the data answer the study question I set out to ask? This is now &quot;feed backwards validation&quot;.</li>
<li>Write-up including the 'nitty-gritty' of the user study, and a statement like &quot;Given our definition of easy, our multiple operationalisations of the concept of easy show that this is infact objectively true/false&quot;.</li>
</ol>
<h3 id="pilots">Pilots</h3>
<p>We also spoke about ideas for pilot studies -- asking &quot;What might be surprising insights into declarative programming languages for User Interface Design -- the case of Elm?&quot;.</p>
<p>Speak-aloud protocols where you prompt/facilitate the user to say what is on their mind when that e.g. pause for more than 10 seconds -- a measurement I set out to look for during an experiment.</p>
<p>I might ask &gt; I notice you have paused for at least 10 seconds -- why did you? &gt;&gt; I thought the code would do X, but it did Y. &gt; Why did you think it would do X? &gt;&gt; ...</p>
<p>I must ask the participant questions designed in a way that they are not leading.</p>
<p>Leon suggested I gather a rich data set, as it's difficult to take notes AND prompt the user during an experiment. SO difficult. Perhaps record video.</p>
<h2 id="actions-for-next-meeting">Actions for next meeting</h2>
<p>Devise a Pilot study, answering these 3 questions:</p>
<ol style="list-style-type: decimal">
<li>What might I ask people to do?</li>
<li>How will I gather data?</li>
<li>How will I analyse the data?</li>
</ol>
<p>Also see paper Leon will send me on &quot;Thematic analysis &amp; Psychology&quot;</p>
<hr />
<h1 id="wed-mar-25-1430-gmt-2014">Wed Mar 25 14:30 GMT 2014</h1>
<p>(Several meetings undocumented)</p>
<p>TODO: Refer to notes in Diary for previous entries.</p>
<h2 id="progress-since-last-meeting">Progress since last meeting</h2>
<p>Discussed findings from analysis of pilot study</p>
<h3 id="observation-1">Observation 1</h3>
<ul>
<li><p>Prompting <em>&quot;What are you thinking about?&quot;</em> etc. seemed to place additional cognitive load on the user as they spent longer resuming than when not prompted. This caused noise in assessing the actual cognitive load incurred during the completion of the <strong>task</strong>. Were the signs of struggling/undergoing difficulty due to simply not understanding the language, or were they due to the difficulty of the task?</p></li>
<li><p>In particular, the majority of instances where the users paused turned out to be confusion as to the semantics &amp; syntax of the language.</p></li>
</ul>
<h3 id="model-adjustment-1">Model Adjustment 1</h3>
<ul>
<li>Add tooltips that appear as the user places the keyboard cursor to the right of a token in the language.</li>
</ul>
<h3 id="observation-2">Observation 2</h3>
<ul>
<li>Sifting through 1-hour+ of video data capture for incidences of cognitive load is <em>HARD!</em>. Is there some programmatic way of narrowing the video data to points of interest?</li>
</ul>
<h3 id="model-adjustment-2">Model Adjustment 2</h3>
<ul>
<li><p>Track the user mouse and keyboard movements in a 3-tuple: (Time t, (Mouse.x, Mouse.y), Keypress k)</p></li>
<li><p>It doesn't have to be implemented this way. I could extend <strong>Model Adjustment 1</strong> to define blocks of code as tokens in themselves, and capture how long the cursor is static on that particular token.</p></li>
<li><p>Leon suggested a further refinement of this idea in order to further narrow the data (in fact, just capturing mouse &amp; keyboard movements will result in an explosion of the volume of data -- countrary to what I intend to achieve). His refinement was to define regions of interest in the code pane, and <em>only when the mouse/key cursor is in the region, do I capture data</em>.</p></li>
<li><p>Use the <code>if cursor in region then log (Time t, (Mouse.x, Mouse.y), Keypress   k)</code> functionality as a <em>lens</em> to focus on significant portions of video capture.</p></li>
</ul>
<h1 id="further-discussion">Further discussion</h1>
<p>We then discussed some questions that might lead my direction of study in the next steps of my research:</p>
<ul>
<li><p>Is the mouse/cursor position a proxy for someone's attention as they carry out the task?</p></li>
<li><p>Often when I'm coding I'll leave the cursor where it is but think about other regions of code. I don't necessarily move the keyboard/mouse cursor to the section of code I'm thinking about. Instead, I use it as a 'bookmark' to track what I'm currently implementing, and may scroll around to other parts.</p></li>
</ul>
<h1 id="actions">Actions</h1>
<ol style="list-style-type: decimal">
<li>Design a task in JavaScript to go inside this adjusted model (incorporating Model Adjustment 1 and 2).</li>
</ol>
<p>This will require a degree of <em>&quot;implementation juggling&quot;</em> in order to find a balance of code-length/difficulty over the same task in Elm in such a way that is not creating noise in the thing being studied: Cognitive load.</p>
<p>Keep the reactivity constant, compare the differences in ease between JS and Elm.</p>
<ol start="2" style="list-style-type: decimal">
<li>If time available, run another Pilot study on this task + adjusted model</li>
</ol>
</body>
</html>
